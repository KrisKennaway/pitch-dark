;license:MIT
;(c) 2018 by 4am
;
; Game descriptions and configuration
;
; Public functions
; - LoadGameInfo
;
; Public variables
; - gCurrentGame
;
; Public constants
; - kNumberOfGames
; - GAMES
;

!zone {
kNumberOfGames = 25
gCurrentGame
         !byte $FD                   ; set at runtime
kTextRootDirectory
         !byte 5
         !raw "TEXT/"
GAMES                                ; length of this array must = kNumberOfGames, there is no range checking
         !word .ballyhoo
         !word .cutthroats
         !word .deadline
         !word .enchanter
         !word .hgttg
         !word .hollywoodhijinx
         !word .infidel
         !word .leathergoddesses
         !word .lurkinghorror
         !word .minizork
         !word .moonmist
         !word .planetfall
         !word .plunderedhearts
         !word .seastalker
         !word .sorcerer
         !word .spellbreaker
         !word .starcross
         !word .stationfall
         !word .suspect
         !word .suspended
         !word .wishbringer
         !word .witness
         !word .zorki
         !word .zorkii
         !word .zorkiii

; length-prefixed names of each subdirectory in game directory, 1 per game
.ballyhoo
         !byte 8
         !raw  "BALLYHOO"
.cutthroats
         !byte 10
         !raw  "CUTTHROATS"
.deadline
         !byte 8
         !raw  "DEADLINE"
.enchanter
         !byte 9
         !raw  "ENCHANTER"
.hgttg
         !byte 5
         !raw  "HGTTG"
.hollywoodhijinx
         !byte 9
         !raw  "HOLLYWOOD"
.infidel
         !byte 7
         !raw  "INFIDEL"
.leathergoddesses
         !byte 4
         !raw  "LGOP"
.lurkinghorror
         !byte 14
         !raw  "LURKING.HORROR"
.minizork
         !byte 9
         !raw  "MINI.ZORK"
.moonmist
         !byte 8
         !raw  "MOONMIST"
.planetfall
         !byte 10
         !raw  "PLANETFALL"
.plunderedhearts
         !byte 9
         !raw  "PLUNDERED"
.seastalker
         !byte 10
         !raw  "SEASTALKER"
.sorcerer
         !byte 8
         !raw  "SORCERER"
.spellbreaker
         !byte 12
         !raw  "SPELLBREAKER"
.starcross
         !byte 9
         !raw  "STARCROSS"
.stationfall
         !byte 11
         !raw  "STATIONFALL"
.suspect
         !byte 7
         !raw  "SUSPECT"
.suspended
         !byte 9
         !raw  "SUSPENDED"
.wishbringer
         !byte 11
         !raw  "WISHBRINGER"
.witness
         !byte 7
         !raw  "WITNESS"
.zorki
         !byte 6
         !raw  "ZORK.I"
.zorkii
         !byte 7
         !raw  "ZORK.II"
.zorkiii
         !byte 8
         !raw  "ZORK.III"

.BEGIN_PARSER_DATA
bInSectionName
         !byte 0
bFoundCR
         !byte 0
iSection
         !byte 0
iSectionsFound
         !byte 0

; array of pointers to start of each section (order must match code)
sectionPointers
addrInfo
         !word 0
addrDescription
         !word 0
addrVersions
         !word 0
.END_PARSER_DATA

;------------------------------------------------------------------------------
; LoadGameInfo
; load file with information about the current game
;
; in:    gCurrentGame between 0 and (kNumberOfGames-1)
; out:   if success, C clear and addrInfo, addrDescription, addrVersions
;          populated with pointers to parsed data
;        if error, C set
;        all other registers and flags clobbered
;------------------------------------------------------------------------------
LoadGameInfo
         jsr   ResetPath
         lda   #<kTextRootDirectory
         ldy   #>kTextRootDirectory
         jsr   AddToPath
         lda   gCurrentGame
         asl
         tax
         lda   GAMES,x
         ldy   GAMES+1,x
         jsr   AddToPath

         jsr   LoadFile
         !word gPathname
         !word $0800
         !word $1400
         !word kProDOSFileBuffer
         bcc   .parseGameInfo
         rts

.parseGameInfo
         ldx   #9                    ; .END_PARSER_DATA-.BEGIN_PARSER_DATA-1
-        stz   .BEGIN_PARSER_DATA,x
         dex
         bpl   -
         stz   $00
         lda   #$08
         sta   $01
         lda   mlilen
         sta   $02
         lda   mlilen+1
         sta   $03
parseloop
         lda   ($00)
         cmp   #$0D                  ; CR -> 0x00 (WeeGUI wants null-terminated strings)
         bne   .notCR
         lda   #$00
         sta   ($00)
         lda   #$FF
         sta   bFoundCR
         bra   .next
.notCR
         cmp   #$5B                  ; '[' is section name start delimiter
         beq   .startsectionname
         cmp   #$5D                  ; ']' is section name end delimiter
         beq   .endsectionname
         bit   bInSectionName
         bmi   .parsesectionname
         bvs   .next
         tax
         beq   .nohighbit
         cmp   #$5E                  ; '^' -> closed-apple mousetext
         bne   +
         lda   #$40
         sta   ($00)
         bra   .nohighbit
+        cmp   #$26                  ; '&' -> open-apple mousetext
         bne   .highbit
         lda   #$41
         sta   ($00)
         bra   .nohighbit
.highbit
         ora   #$80
         sta   ($00)
.nohighbit
         bit   bFoundCR
         bpl   .next
         stz   bFoundCR
         lda   iSection
         beq   .next
; We found the start of the first line after the end of the section name.
; Save this address in the sectionPointers array.
         asl
         tax
         lda   $00
         sta   sectionPointers-2,x
         lda   $01
         sta   sectionPointers-1,x
         stz   iSection
         bra   .next
.startsectionname
         lda   #%11000000
         sta   bInSectionName
         bra   .next
.endsectionname
         stz   bInSectionName
         bra   .next
.parsesectionname
         pha
         lda   #%01000000
         sta   bInSectionName
         pla
         cmp   #$69                  ; 'i'nfo
         beq   .info
         cmp   #$64                  ; 'd'escription
         beq   .description
         cmp   #$76                  ; 'v'ersions
         beq   .versions
         bne   .next
.info
         lda   #1
         !byte $2C                   ; hide next LDA
.description
         lda   #2
         !byte $2C                   ; hide next LDA
.versions
         lda   #3
         sta   iSection
         inc   iSectionsFound
.next
         inc   $00
         bne   +
         inc   $01
+        dec   $02
         bne   +
         dec   $03
         bmi   .done
+        jmp   parseloop
.done
         lda   iSectionsFound
         cmp   #$03
         bne   +
         clc
         rts
+        sec
         rts
}
