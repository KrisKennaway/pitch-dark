kNumberOfGames = 25

gCurrentGame
         !byte 22
kGameDirectory                       ; length-prefixed pathname of where game subdirectories are stored
         !byte 2
         !raw "Z/"
kInfoFilename                        ; length-prefixed partial pathname of game info file, starting with '/' because reasons
         !byte 5
         !raw  "/INFO"

subdirectories                       ; length of this array must = kNumberOfGames, there is no range checking
         !word .ballyhoo
         !word .cutthroats
         !word .deadline
         !word .enchanter
         !word .hgttg
         !word .hollywoodhijinx
         !word .infidel
         !word .leathergoddesses
         !word .lurkinghorror
         !word .minizork
         !word .moonmist
         !word .planetfall
         !word .plunderedhearts
         !word .seastalker
         !word .sorcerer
         !word .spellbreaker
         !word .starcross
         !word .stationfall
         !word .suspect
         !word .suspended
         !word .wishbringer
         !word .witness
         !word .zorki
         !word .zorkii
         !word .zorkiii

; length-prefixed names of each subdirectory in game directory, 1 per game
.ballyhoo
         !byte 8
         !raw  "BALLYHOO"
.cutthroats
         !byte 10
         !raw  "CUTTHROATS"
.deadline
         !byte 8
         !raw  "DEADLINE"
.enchanter
         !byte 9
         !raw  "ENCHANTER"
.hgttg
         !byte 5
         !raw  "HGTTG"
.hollywoodhijinx
         !byte 9
         !raw  "HOLLYWOOD"
.infidel
         !byte 7
         !raw  "INFIDEL"
.leathergoddesses
         !byte 4
         !raw  "LGOP"
.lurkinghorror
         !byte 14
         !raw  "LURKING.HORROR"
.minizork
         !byte 9
         !raw  "MINI.ZORK"
.moonmist
         !byte 8
         !raw  "MOONMIST"
.planetfall
         !byte 10
         !raw  "PLANETFALL"
.plunderedhearts
         !byte 9
         !raw  "PLUNDERED"
.seastalker
         !byte 10
         !raw  "SEASTALKER"
.sorcerer
         !byte 8
         !raw  "SORCERER"
.spellbreaker
         !byte 12
         !raw  "SPELLBREAKER"
.starcross
         !byte 9
         !raw  "STARCROSS"
.stationfall
         !byte 11
         !raw  "STATIONFALL"
.suspect
         !byte 7
         !raw  "SUSPECT"
.suspended
         !byte 9
         !raw  "SUSPENDED"
.wishbringer
         !byte 11
         !raw  "WISHBRINGER"
.witness
         !byte 7
         !raw  "WITNESS"
.zorki
         !byte 6
         !raw  "ZORK.I"
.zorkii
         !byte 7
         !raw  "ZORK.II"
.zorkiii
         !byte 8
         !raw  "ZORK.III"

!zone {
LoadGameInfo
         stz   .path
         lda   #<kGameDirectory
         ldy   #>kGameDirectory
         jsr   addToPath
         lda   gCurrentGame
         asl
         tax
         lda   subdirectories,x
         ldy   subdirectories+1,x
         jsr   addToPath
         lda   #<kInfoFilename
         ldy   #>kInfoFilename
         jsr   addToPath

         jsr   LoadFile
         !word .path
         !word $0800
         !word $1400
         !word $1C00

; initialize all parser data
         ldx   #9                    ; .END_PARSER_DATA-.BEGIN_PARSER_DATA-1
-        stz   .BEGIN_PARSER_DATA,x
         dex
         bpl   -
         stz   $00
         lda   #$08
         sta   $01
         lda   mlilen
         sta   $02
         lda   mlilen+1
         sta   $03
parseloop
         lda   ($00)
; Replace all carriage returns with zeroes,
; because WeeGUI wants zero-terminated strings
; but I want to be able to edit files in a text editor.
         cmp   #$0D
         bne   +
         lda   #$00
         sta   ($00)
         lda   #$FF
         sta   bFoundCR
         bra   .next
+        cmp   #$5E                  ; '^' -> closed-apple mousetext
         bne   +
         lda   #$40
         sta   ($00)
+        cmp   #$26                  ; '&' -> open-apple mousetext
         bne   +
         lda   #$41
         sta   ($00)
+        cmp   #$5B                  ; '[' is section name start delimiter
         beq   .startsectionname
         cmp   #$5D                  ; ']' is section name end delimiter
         beq   .endsectionname
         bit   bInSectionName
         bmi   .parsesectionname
         bvs   .next
         bit   bFoundCR
         bpl   .next
         stz   bFoundCR
         lda   iSection
         beq   .next
; We found the start of the first line after the end of the section name.
; Save this address in the sectionPointers array.
         asl
         tax
         lda   $00
         sta   sectionPointers-2,x
         lda   $01
         sta   sectionPointers-1,x
         stz   iSection
         bra   .next
.startsectionname
         lda   #%11000000
         sta   bInSectionName
         bra   .next
.endsectionname
         stz   bInSectionName
         bra   .next
.parsesectionname
         pha
         lda   #%01000000
         sta   bInSectionName
         pla
         cmp   #$69                  ; 'i'nfo
         beq   .info
         cmp   #$64                  ; 'd'escription
         beq   .description
         cmp   #$76                  ; 'v'ersions
         beq   .versions
         bne   .next
.info
         lda   #1
         !byte $2C                   ; hide next LDA
.description
         lda   #2
         !byte $2C                   ; hide next LDA
.versions
         lda   #3
         sta   iSection
         inc   iSectionsFound
.next
         inc   $00
         bne   +
         inc   $01
+        dec   $02
         bne   +
         dec   $03
         bmi   .done
+        jmp   parseloop
.done
         lda   iSectionsFound
         cmp   #$03
         bne   +
         clc
         rts
+        sec
         rts
.BEGIN_PARSER_DATA
bInSectionName
         !byte 0
bFoundCR
         !byte 0
iSection
         !byte 0
iSectionsFound
         !byte 0

sectionPointers                      ; array of pointers to start of each section (order matches constants used by parser)
addrInfo
         !word 0
addrDescription
         !word 0
addrVersions
         !word 0
.END_PARSER_DATA

addToPath
         sta   $00
         sty   $01
         ldx   .path                 ; current pathname length
         ldy   #$00
         lda   ($00),y               ; length of this segment
         inc
         sta   .a+1
         ldy   #$01
-        lda   ($00),y
         sta   .pathbuffer,x
         inx
         iny
.a       cpy   #$FD                  ; set at runtime
         bcc   -
         stx   .path
         rts
.path
         !byte $FD                   ; set at runtime
.pathbuffer
         !fill 64                    ; enough zeroes for any ProDOS pathname
}
